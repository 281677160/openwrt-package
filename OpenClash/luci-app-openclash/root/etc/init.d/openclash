#!/bin/sh /etc/rc.common
# Copyright (c) 2019 vernesong
. /usr/share/openclash/openclash_ps.sh

START=99
STOP=15

LOGTIME=$(date "+%Y-%m-%d %H:%M:%S")
CLASH="/etc/openclash/clash"
CLASH_CONFIG="/etc/openclash"
CRON_FILE="/etc/crontabs/root"
CONFIG_FILE=$(uci get openclash.config.config_path 2>/dev/null)
LOG_FILE="/tmp/openclash.log"
START_LOG="/tmp/openclash_start.log"
BACKUP_FILE="/etc/openclash/backup/$(uci get openclash.config.config_path 2>/dev/null |awk -F '/' '{print $5}' 2>/dev/null)"
START_BACKUP="/tmp/config.sbak"
CHANGE_FILE="/tmp/yaml_change.yaml"
SCRIPT_FILE="/tmp/yaml_script.yaml"
SCRIPT_BAK_FILE="/tmp/yaml_script_bak.yaml"
RULE_PROVIDER_FILE="/tmp/yaml_rule_provider.yaml"
RULE_PROVIDER_BAK_FILE="/tmp/yaml_rule_provider_bak.yaml"
RULE_FILE="/tmp/yaml_rules.yaml"
RULE_BAK_FILE="/tmp/yaml_rules_bak.yaml"
DNS_FILE="/tmp/yaml_dns.yaml"
PROXY_FILE="/tmp/yaml_proxy.yaml"
PROXY_PROVIDER_FILE="/tmp/yaml_proxy_provider.yaml"
GROUP_FILE="/tmp/yaml_group.yaml"
GAME_RULE_FILE="/tmp/yaml_game_rule_group.yaml"
CFW_LATE_FILE="/tmp/yaml_cfw_late_file.yaml"
CFW_PASS_FILE="/tmp/yaml_cfw_pass_file.yaml"
FALLBACK_FILTER_FILE="/tmp/yaml_fallback_filter_file.yaml"
HOSTS_FILE="/etc/openclash/custom/openclash_custom_hosts.list"
PROXY_FWMARK="0x162"
PROXY_ROUTE_TABLE="0x162"

add_cron()
{
   [ "$(tail -n1 /etc/crontabs/root | wc -l)" -eq 0 ] && [ -n "$(cat /etc/crontabs/root 2>/dev/null)" ] && echo >> /etc/crontabs/root
   [ -z "$(grep "openclash.sh" "$CRON_FILE" 2>/dev/null)" ] && {
      [ "$(uci get openclash.config.auto_update 2>/dev/null)" -eq 1 ] && [ "$(uci get openclash.config.config_auto_update_mode 2>/dev/null)" -ne 1 ] && echo "0 $(uci get openclash.config.auto_update_time 2>/dev/null) * * $(uci get openclash.config.config_update_week_time 2>/dev/null) /usr/share/openclash/openclash.sh" >> $CRON_FILE
   }
   [ -z "$(grep "openclash_rule.sh" "$CRON_FILE" 2>/dev/null)" ] && {
      [ "$(uci get openclash.config.other_rule_auto_update 2>/dev/null)" -eq 1 ] && echo "0 $(uci get openclash.config.other_rule_update_day_time 2>/dev/null) * * $(uci get openclash.config.other_rule_update_week_time 2>/dev/null) /usr/share/openclash/openclash_rule.sh" >> $CRON_FILE
   }
   [ -z "$(grep "openclash_ipdb.sh" "$CRON_FILE" 2>/dev/null)" ] && {
      [ "$(uci get openclash.config.geo_auto_update 2>/dev/null)" -eq 1 ] && echo "0 $(uci get openclash.config.geo_update_day_time 2>/dev/null) * * $(uci get openclash.config.geo_update_week_time 2>/dev/null) /usr/share/openclash/openclash_ipdb.sh" >> $CRON_FILE
   }
   [ -z "$(grep "openclash_chnroute.sh" "$CRON_FILE" 2>/dev/null)" ] && {
      [ "$(uci get openclash.config.chnr_auto_update 2>/dev/null)" -eq 1 ] && echo "0 $(uci get openclash.config.chnr_update_day_time 2>/dev/null) * * $(uci get openclash.config.chnr_update_week_time 2>/dev/null) /usr/share/openclash/openclash_chnroute.sh" >> $CRON_FILE
   }
   crontab $CRON_FILE
   nohup /usr/share/openclash/openclash_watchdog.sh &
}

del_cron()
{
   sed -i '/openclash.sh/d' $CRON_FILE 2>/dev/null
   sed -i '/openclash_rule.sh/d' $CRON_FILE 2>/dev/null
   sed -i '/openclash_ipdb.sh/d' $CRON_FILE 2>/dev/null
   sed -i '/openclash_chnroute.sh/d' $CRON_FILE 2>/dev/null
   /etc/init.d/cron restart
}

change_dns() {
   if [ "$1" -eq 1 ]; then
      uci del dhcp.@dnsmasq[-1].server >/dev/null 2>&1
      uci add_list dhcp.@dnsmasq[0].server=127.0.0.1#"$dns_port"
      uci delete dhcp.@dnsmasq[0].resolvfile 2>/dev/null
      uci set dhcp.@dnsmasq[0].noresolv=1 2>/dev/null
      uci set openclash.config.redirect_dns=1
   else
      uci set openclash.config.redirect_dns=0 2>/dev/null
   fi
   if [ "$2" -eq 1 ]; then
      uci set dhcp.@dnsmasq[0].cachesize=0 2>/dev/null
   fi
   
   uci commit dhcp
   uci commit openclash
   
   /usr/share/openclash/openclash_custom_domain_dns.sh >/dev/null 2>&1
}

revert_dns() {

   [ "$1" -eq 1 ] && {
      uci del_list dhcp.@dnsmasq[0].server=127.0.0.1#"$3" >/dev/null 2>&1
   }
   
   [ "$1" -eq 1 ] && [ "$4" -eq 0 ] && {
      uci set openclash.config.redirect_dns=0 2>/dev/nulls
   }

   [ "$(uci get dhcp.@dnsmasq[0].cachesize 2>/dev/null)" = "0" ] && {
      uci delete dhcp.@dnsmasq[0].cachesize >/dev/null 2>&1
   }
   
   [ "$1" -eq 1 ] && {
      if [ -s "/tmp/resolv.conf.d/resolv.conf.auto" ]; then
         uci set dhcp.@dnsmasq[0].resolvfile=/tmp/resolv.conf.d/resolv.conf.auto >/dev/null 2>&1
      elif [ -s "/tmp/resolv.conf.auto" ]; then
         uci set dhcp.@dnsmasq[0].resolvfile=/tmp/resolv.conf.auto >/dev/null 2>&1
      fi
      uci set dhcp.@dnsmasq[0].noresolv=0 >/dev/null 2>&1
   }
   
   uci commit dhcp
   uci commit openclash
   rm -rf /tmp/dnsmasq.d/dnsmasq_openclash.conf >/dev/null 2>&1
   rm -rf /tmp/dnsmasq.d/dnsmasq_openclash_custom_domain.conf >/dev/null 2>&1
}

kill_clash()
{
   clash_pids=$(pidof clash |sed 's/$//g')
   for clash_pid in $clash_pids; do
      kill -9 "$clash_pid" 2>/dev/null
   done >/dev/null 2>&1
   sleep 1
}

start_fail()
{
   kill_clash
   stop
   exit 0
}

yml_merge()
{
#合并文件
cat "$CHANGE_FILE" "$DNS_FILE" "$PROXY_PROVIDER_FILE" "$PROXY_FILE" "$GROUP_FILE" "$RULE_PROVIDER_FILE" "$SCRIPT_FILE" "$RULE_FILE" > "$CONFIG_FILE" 2>/dev/null
}

yml_rule_bak_merge()
{
#合并文件
cat "$CHANGE_FILE" "$DNS_FILE" "$PROXY_PROVIDER_FILE" "$PROXY_FILE" "$GROUP_FILE" "$RULE_PROVIDER_BAK_FILE" "$SCRIPT_BAK_FILE" "$RULE_BAK_FILE" > "$CONFIG_FILE" 2>/dev/null
}

yml_check()
{
	
   #创建启动备份
   cp "$3" "$5"
   
   #创建原始备份
   if [ ! -f "$4" ]; then
      cp "$3" "$4"
   fi
   
   #格式替换
   sed -i 's/\t/ /g' "$3" 2>/dev/null
   sed -i "s/- \{2,\}/- /g" "$3" 2>/dev/null
   sed -i "s/^\.\.\.$//g" "$3" 2>/dev/null
   sed -i "s/^---$//g" "$3" 2>/dev/null
   sed -i "s/^ \{1,\}dns:/dns:/g" "$3" 2>/dev/null
   sed -i '/OpenClash-General/d' "$3" 2>/dev/null

   #检查关键字避免后续操作出错
   /usr/share/openclash/yml_field_name_ch.sh "$3" 2>/dev/null

   #取出general部分
   /usr/share/openclash/yml_field_cut.sh "general" "$CHANGE_FILE" "$3"
   
   #取出dns部分
   nameserver_len=$(sed -n '/^ \{0,\}nameserver:/=' "$3" 2>/dev/null)
   if [ -n "$nameserver_len" ]; then
      /usr/share/openclash/yml_field_cut.sh "$nameserver_len" "$DNS_FILE" "$3"
   else
      fallback_len=$(sed -n '/^ \{0,\}fallback:/=' "$3" 2>/dev/null)
      if [ -n "$fallback_len" ]; then
   	     /usr/share/openclash/yml_field_cut.sh "$fallback_len" "$DNS_FILE" "$3"
   	  fi
   fi 2>/dev/null
   
   #取出proxy部分
   proxy_lens=$(sed -n '/^Proxy:/=' "$3" 2>/dev/null)
   proxy_len_num=1
   for proxy_len in $proxy_lens; do
      if [ -n "$proxy_len" ]; then
         /usr/share/openclash/yml_field_cut.sh "$proxy_len" "/tmp/yaml_proxy_$proxy_len_num.yaml" "$3"
      fi 2>/dev/null
      proxy_len_num=$(expr "$proxy_len_num" + 1)
   done 2>/dev/null
   for i in $(seq "$proxy_len_num"); do
      cat "/tmp/yaml_proxy_$i.yaml" >> $PROXY_FILE
   done 2>/dev/null
   
   #取出proxy-providers部分
   provider_len=$(sed -n '/^proxy-providers:/=' "$3" 2>/dev/null)
   if [ -n "$provider_len" ]; then
      /usr/share/openclash/yml_field_cut.sh "$provider_len" "$PROXY_PROVIDER_FILE" "$3"
   fi 2>/dev/null
   
   #取出group部分
   group_len=$(sed -n '/^proxy-groups:/=' "$3" 2>/dev/null)
   if [ -n "$group_len" ]; then
      /usr/share/openclash/yml_field_cut.sh "$group_len" "$GROUP_FILE" "$3"
   fi 2>/dev/null
   
   #取出rule_provider部分
   rule_provider_len=$(sed -n '/^rule-providers:/=' "$3" 2>/dev/null)
   if [ -n "$rule_provider_len" ]; then
      /usr/share/openclash/yml_field_cut.sh "$rule_provider_len" "$RULE_PROVIDER_FILE" "$3"
   fi 2>/dev/null
   
   #取出script部分
   script_len=$(sed -n '/^script:/=' "$3" 2>/dev/null)
   if [ -n "$script_len" ]; then
      /usr/share/openclash/yml_field_cut.sh "$script_len" "$SCRIPT_FILE" "$3"
   fi 2>/dev/null
    
   #取出rule部分
   rule_len=$(sed -n '/^rules:/=' "$3" 2>/dev/null)
   if [ -n "$rule_len" ]; then
      /usr/share/openclash/yml_field_cut.sh "$rule_len" "$RULE_FILE" "$3"
   fi 2>/dev/null
   
   #取出cfw部分
   cfw_bypass_len=$(sed -n '/^ \{0,\}cfw-bypass:/=' "$DNS_FILE" 2>/dev/null)
   if [ -n "$cfw_bypass_len" ]; then
      /usr/share/openclash/yml_field_cut.sh "$cfw_bypass_len" "$CFW_LATE_FILE" "$DNS_FILE" "dns"
   fi 2>/dev/null
   
   #取出cfw部分
   cfw_latency_timeout_len=$(sed -n '/^ \{0,\}cfw-latency-timeout:/=' "$DNS_FILE" 2>/dev/null)
   if [ -n "$cfw_latency_timeout_len" ]; then
      /usr/share/openclash/yml_field_cut.sh "$cfw_latency_timeout_len" "$CFW_LATE_FILE" "$DNS_FILE" "dns"
   fi 2>/dev/null
   
   #取出fallback-filter部分
   fallback_filter_len=$(sed -n '/^ \{0,\}fallback-filter:/=' "$DNS_FILE" 2>/dev/null)
   if [ -n "$fallback_filter_len" ]; then
      /usr/share/openclash/yml_field_cut.sh "$fallback_filter_len" "$FALLBACK_FILTER_FILE" "$DNS_FILE" "dns"
   fi 2>/dev/null

   #备份rule_provider部分
   rule_provider_bak_len=$(sed -n '/^rule-providers:/=' "$4" 2>/dev/null)
   if [ -n "$rule_provider_bak_len" ]; then
      /usr/share/openclash/yml_field_cut.sh "$rule_provider_bak_len" "$RULE_PROVIDER_BAK_FILE" "$4"
   fi 2>/dev/null
   
   #备份script部分
   script_bak_len=$(sed -n '/^script:/=' "$4" 2>/dev/null)
   if [ -n "$script_bak_len" ]; then
      /usr/share/openclash/yml_field_cut.sh "$script_bak_len" "$SCRIPT_BAK_FILE" "$4"
   fi 2>/dev/null
   
   #备份rule部分
   rule_bak_len=$(sed -n '/^rules:/=' "$4" 2>/dev/null)
   if [ -n "$rule_bak_len" ]; then
      /usr/share/openclash/yml_field_cut.sh "$rule_bak_len" "$RULE_BAK_FILE" "$4"
   fi 2>/dev/null
   
   #检查DNS字段
   if [ -z "$(grep '^dns:' "$CHANGE_FILE")" ]; then
      echo "dns:" >> "$CHANGE_FILE" 2>/dev/null
   fi
   
   #检查general部分的缩进
   if [ -n "$(grep "^ \{1,\}port:" "$CHANGE_FILE")" ] || [ -n "$(grep "^ \{1,\}mode:" "$CHANGE_FILE")" ] || [ -n "$(grep "^ \{1,\}log-level:" "$CHANGE_FILE")" ]; then
      cp "$CHANGE_FILE" /tmp/config.check 2>/dev/null
      sed -i '/^dns:/,$d' /tmp/config.check 2>/dev/null
      sed -i 's/^[ \t]*//' /tmp/config.check 2>/dev/null
      sed -n '/^dns:/,$p' "$CHANGE_FILE" >> /tmp/config.check 2>/dev/null
      mv /tmp/config.check "$CHANGE_FILE" 2>/dev/null
   fi
   
   #自定义DNS还原
   if [ "$(grep -c '##Custom DNS##' "$CHANGE_FILE")" -gt 0 ] || [ "$(grep -c '##Custom DNS##' "$DNS_FILE")" -gt 0 ]; then
      if [ "$2" = 0 ] && [ -f "$4" ]; then
         #取出dns备份
         nameserver_len=$(sed -n '/^ \{0,\}nameserver:/=' "$4" 2>/dev/null)
         if [ -n "$nameserver_len" ]; then
            /usr/share/openclash/yml_field_cut.sh "$nameserver_len" "/tmp/backdns.config" "$4"
         else
            fallback_len=$(sed -n '/^ \{0,\}fallback:/=' "$3" 2>/dev/null)
            if [ -n "$fallback_len" ]; then
               /usr/share/openclash/yml_field_cut.sh "$fallback_len" "/tmp/backdns.config" "$4"
            fi
         fi 2>/dev/null
         rm -rf "$DNS_FILE" 2>/dev/null
         rm -rf "$FALLBACK_FILTER_FILE" 2>/dev/null
         sed -i '/##Custom DNS##/d' "$CHANGE_FILE" 2>/dev/null
         cat "/tmp/backdns.config" >> "$DNS_FILE" 2>/dev/null
         rm -rf /tmp/backdns.config 2>/dev/null
      fi
   fi 2>/dev/null
   #检查DNS服务
   if [ -z "$(grep '^ \{0,\}nameserver:' "$DNS_FILE")" ] || [ -z "$(sed '/^ \{0,\}fallback/,$d' "$DNS_FILE" 2>/dev/null |grep '^ \{0,\}- ')" ]; then
      echo "检测到DNS选项下的Nameserver未设置服务器，开始补全..." >$START_LOG
      echo "${LOGTIME} Nameserver Option Must Be Setted, Auto Completed" >>$LOG_FILE
      echo "  nameserver:" > "$DNS_FILE" 2>/dev/null
      cat >> "$DNS_FILE" <<-EOF
    - 114.114.114.114
    - 119.29.29.29
  fallback:
    - https://cloudflare-dns.com/dns-query
    - https://dns.google/dns-query
    - https://1.1.1.1/dns-query
    - tls://8.8.8.8:853
EOF
   sleep 2
   fi
  
   dns_port=$(grep "^ \{0,\}listen:" "$CHANGE_FILE" |awk -F ':' '{print $3}' |awk -F '#' '{print $1}' |tr -cd "[0-9]" 2>/dev/null)
   if [ -z "$dns_port" ] || [ "$dns_port" -eq 53 ]; then
      dns_port=7874
   fi

   #保存DNS端口方便后续调用
   uci set openclash.config.dns_port="$dns_port" && uci commit openclash
   
   #添加标识
   echo '#===================== OpenClash-General-Settings =====================#' >> "$FALLBACK_FILTER_FILE" 2>/dev/null
}

#修改集路径
yml_provider_path()
{
   provider_path_line=$(sed -n '/ \{0,\}path/=' "$1" 2>/dev/null)
   if [ -n "$provider_path_line" ]; then
      for n in $provider_path_line; do
         if [ -n "$(sed -n "${n}p" "$1" |grep "^ \{0,\}#")" ]; then
            continue
         fi
         provider_path=$(sed -n "${n}p" "$1" |sed "s/\'//g" |sed 's/\"//g' |awk -F 'path:' '{print $2}' 2>/dev/null |awk -F '#' '{print $1}' 2>/dev/null |sed 's/,.*//' 2>/dev/null |sed 's/^ \{0,\}//g' 2>/dev/null |sed 's/ \{0,\}$//g' 2>/dev/null |sed 's/ \{0,\}\}\{0,\}$//g' 2>/dev/null)
         if [ -z "$(echo "$provider_path" |grep "$2")" ]; then
            provider_name=$(echo "$provider_path" |awk -F '/' '{print $NF}')
            sed -i "s#path: ${provider_path}#path: ./${2}/${provider_name}#" "$1" 2>/dev/null
            sed -i "s#\"${provider_path}#\"./${2}/${provider_name}#" "$1" 2>/dev/null
            sed -i "s#\'${provider_path}#\'./${2}/${provider_name}#" "$1" 2>/dev/null
            sed -i "s#\:${provider_path}#\:./${2}/${provider_name}#" "$1" 2>/dev/null
            uci set openclash.config.config_reload=0 2>/dev/null
            uci commit openclash
         fi
      done
   fi 2>/dev/null
}

#检查集文件防止启动失败
yml_provider_check()
{
provider_path_line=$(sed -n '/ \{0,\}path/=' "$1" 2>/dev/null)
local provider_path_exist provider_path_check_num
provider_path_check_num=1
if [ -n "$provider_path_line" ]; then
   while ( [ -n "$(pidof clash)" ] && [ "$provider_path_exist" != 1 ] && [ "$provider_path_check_num" -le 5 ] )
   do
      provider_path_exist=1
      for n in $provider_path_line; do
         if [ -n "$(sed -n "${n}p" "$1" |grep "^ \{0,\}#")" ]; then
            continue
         fi
         provider_path=$(sed -n "${n}p" "$1" |sed "s/\'//g" |sed 's/\"//g' |awk -F 'path:' '{print $2}' 2>/dev/null |awk -F '#' '{print $1}' 2>/dev/null |sed 's/,.*//' 2>/dev/null |sed 's/^ \{0,\}//g' 2>/dev/null |sed 's/ \{0,\}$//g' 2>/dev/null |sed 's/ \{0,\}\}\{0,\}$//g' 2>/dev/null)
         if [ "$(echo "${provider_path:0:1}")" = "." ]; then
            provider_path_check="/etc/openclash/$(echo ${provider_path:2})"
            if [ -f "$provider_path_check" ] && [ "$2" = "proxy_provider" ]; then
               if [ -z "$(grep "'proxies':" "$provider_path_check")" ] && [ -z "$(grep '"proxies":' "$provider_path_check")" ] && [ -z "$(grep 'proxies:' "$provider_path_check")" ]; then
                  provider_path_exist=0
               fi
            elif [ "$2" = "proxy_provider" ]; then
               provider_path_exist=0
            fi
            if [ -f "$provider_path_check" ] && [ "$2" = "rule_provider" ]; then
               if [ -z "$(grep "'payload':" "$provider_path_check")" ] && [ -z "$(grep '"payload":' "$provider_path_check")" ] && [ -z "$(grep 'payload:' "$provider_path_check")" ]; then
                  provider_path_exist=0
               fi
            elif [ "$2" = "rule_provider" ]; then
               provider_path_exist=0
            fi
         elif [ "$(echo "${provider_path:0:1}")" = "/" ]; then
            provider_path_check="$provider_path"
            if [ -f "$provider_path_check" ] && [ "$2" = "proxy_provider" ]; then
               if [ -z "$(grep "'proxies':" "$provider_path_check")" ] && [ -z "$(grep '"proxies":' "$provider_path_check")" ] && [ -z "$(grep 'proxies:' "$provider_path_check")" ]; then
                  provider_path_exist=0
               fi
            elif [ "$2" = "proxy_provider" ]; then
               provider_path_exist=0
            fi
            if [ -f "$provider_path_check" ] && [ "$2" = "rule_provider" ]; then
               if [ -z "$(grep "'payload':" "$provider_path_check")" ] && [ -z "$(grep '"payload":' "$provider_path_check")" ] && [ -z "$(grep 'payload:' "$provider_path_check")" ]; then
                  provider_path_exist=0
               fi
            elif [ "$2" = "rule_provider" ]; then
               provider_path_exist=0
            fi
         fi
      done
      provider_path_check_num=$(expr "$provider_path_check_num" + 1)
      [ "$provider_path_exist" = 0 ] && sleep 2
   done
fi

if [ -z "$(pidof clash)" ] && [ "$provider_path_exist" = 0 ]; then
   if [ "$2" = "proxy_provider" ]; then
      echo "错误: 代理集文件下载失败，请到日志页面查看详细错误信息！" >$START_LOG
      echo "${LOGTIME} Error: Faild to Download Proxy-Provider File, Please Check The Error Info And Try Again" >> $LOG_FILE
   else
      echo "错误: 规则集文件下载失败，请到日志页面查看详细错误信息！" >$START_LOG
      echo "${LOGTIME} Error: Faild to Download Rule-Provider File, Please Check The Error Info And Try Again" >> $LOG_FILE
   fi
   sleep 10
   start_fail
elif [ "$provider_path_check_num" -gt 5 ]; then
   echo "警告: 代理集文件检查超时，如启动失败请到日志页面查看详细信息！" >$START_LOG
   sleep 3
fi

}

#获取自定义DNS设置
yml_dns_get()
{

   local section="$1"
   local enabled port type ip group dns_type dns_address
   config_get_bool "enabled" "$section" "enabled" "1"
   config_get "port" "$section" "port" ""
   config_get "type" "$section" "type" ""
   config_get "ip" "$section" "ip" ""
   config_get "group" "$section" "group" ""

   if [ "$enabled" = "0" ]; then
      return
   fi

   if [ -z "$ip" ]; then
      return
   fi

   if [ "$type" = "tcp" ]; then
      dns_type="- tcp://"
   elif [ "$type" = "tls" ]; then
      dns_type="- tls://"
   elif [ "$type" = "udp" ]; then
      dns_type="- "
   elif [ "$type" = "https" ]; then
      dns_type="- https://"
   fi

   if [ -n "$port" ] && [ -n "$ip" ]; then
      dns_address="$ip:$port"
   elif [ -z "$port" ] && [ -n "$ip" ]; then
      dns_address="$ip"
   else
      return
   fi

   if [ -n "$group" ]; then
      if [ "$group" = "nameserver" ]; then
      	 if [ -z "$(grep "nameserver:$" /tmp/config.namedns 2>/dev/null)" ]; then
            echo "  nameserver:" >/tmp/config.namedns
         fi
         echo "    $dns_type$dns_address" >>/tmp/config.namedns
      else
         if [ -z "$(grep "fallback:$" /tmp/config.falldns 2>/dev/null)" ]; then
            echo "  fallback:" >/tmp/config.falldns
         fi
         echo "    $dns_type$dns_address" >>/tmp/config.falldns
      fi
   else
      return
   fi
}

#添加自定义DNS设置
yml_dns_custom()
{
   if [ "$1" = 1 ]; then
      config_load "openclash"
      config_foreach yml_dns_get "dns_servers"
      if [ -f "/tmp/config.namedns" ]; then
         sed -i '/^ \{0,\}nameserver:/,$d' "$2" 2>/dev/null
         sed -i "/^ \{0,\}nameserver:/a\##Custom DNS##" "/tmp/config.namedns"
         cat "/tmp/config.namedns" >> "$2" 2>/dev/null
         cat "/tmp/config.falldns" >> "$2" 2>/dev/null
      else
         echo "错误: 配置文件DNS选项下的Nameserver必须设置服务器，已停止设置自定义DNS服务器！" >$START_LOG
         echo "${LOGTIME} Error: Nameserver Option Must Be Setted, Stop Customing DNS Servers" >>$LOG_FILE
         sleep 3
      fi
      rm -rf /tmp/config.namedns 2>/dev/null
      rm -rf /tmp/config.falldns 2>/dev/null
   fi
   
   if [ -z "$(grep "##Custom DNS##" "$2" 2>/dev/null)" ]; then
      sed -i "/^ \{0,\}nameserver:/c\  nameserver:" "$2" 2>/dev/null
      sed -i "/^ \{0,\}fallback:/c\  fallback:" "$2" 2>/dev/null
      sed -i "s/^ \{0,\}- /    - /g" "$2" 2>/dev/null
   fi

#fallback-filter
   if [ -n "$(grep "^ \{0,\}fallback:" "$2")" ] && [ -z "$(grep "^ \{0,\}fallback-filter:" "$3")" ]; then
cat >> "$3" <<-EOF
  fallback-filter:
    geoip: true
    ipcidr:
      - 0.0.0.0/8
      - 10.0.0.0/8
      - 100.64.0.0/10
      - 127.0.0.0/8
      - 169.254.0.0/16
      - 172.16.0.0/12
      - 192.0.0.0/24
      - 192.0.2.0/24
      - 192.88.99.0/24
      - 192.168.0.0/16
      - 198.18.0.0/15
      - 198.51.100.0/24
      - 203.0.113.0/24
      - 224.0.0.0/4
      - 240.0.0.0/4
      - 255.255.255.255/32
EOF
      sed -i '/OpenClash-General/d' "$3" 2>/dev/null
      echo "#===================== OpenClash-General-Settings =====================#" >>"$3"
   elif [ -n "$(grep "^ \{0,\}fallback-filter:" "$3")" ]; then
      if [ -z "$(grep "^  fallback-filter:" "$3")" ]; then
         sed -i "/fallback-filter:/c\  fallback-filter:" "$2" 2>/dev/null
      fi
      if [ -z "$(grep "^    geoip: true" "$3")" ]; then
         sed -i "/geoip: true/c\    geoip: true" "$3" 2>/dev/null
      fi
      if [ -z "$(grep "^    ipcidr:" "$3")" ]; then
         sed -i "/ipcidr:/c\    ipcidr:" "$3" 2>/dev/null
      fi
      if [ -z "$(grep "^      - " "$3")" ]; then
         sed -i '/^ \{0,\}ipcidr:/,/,$/ {s/^ \{0,\}- /      - /g}' "$3" 2>/dev/null #修改参数空格
      fi
   fi

   cat "$3" >> "$2" 2>/dev/null
}

#获取认证信息
yml_auth_get()
{
   local section="$1"
   local enabled username password
   config_get_bool "enabled" "$section" "enabled" "1"
   config_get "username" "$section" "username" ""
   config_get "password" "$section" "password" ""

   if [ "$enabled" = "0" ]; then
      return
   fi

   if [ -z "$username" ] || [ -z "$password" ]; then
      return
   else
      echo "  - $username:$password" >>/tmp/config.auth
   fi
}

#添加认证信息
yml_auth_custom()
{
   if [ -n "$(grep "^authentication:" "$1")" ]; then
      sed -i '/^dns:/i\#authentication' "$1" 2>/dev/null
      sed -i '/^authentication:/,/^#authentication/d' "$1" 2>/dev/null
   fi
   if [ -f /tmp/config.auth ]; then
      sed -i '/^dns:/i\authentication:' "$1" 2>/dev/null
      sed -i '/^authentication:/r/tmp/config.auth' "$1" 2>/dev/null
      rm -rf /tmp/config.auth 2>/dev/null
   fi
}

get_rule_file()
{
   if [ -z "$1" ]; then
      return
   fi
   
   GAME_RULE_FILE_NAME=$(grep "^$1," /usr/share/openclash/res/game_rules.list |awk -F ',' '{print $3}' 2>/dev/null)

   if [ -z "$GAME_RULE_FILE_NAME" ]; then
      GAME_RULE_FILE_NAME=$(grep "^$1," /usr/share/openclash/res/game_rules.list |awk -F ',' '{print $2}' 2>/dev/null)
   fi
   
   GAME_RULE_PATH="/etc/openclash/game_rules/$GAME_RULE_FILE_NAME"
   
   sed '/^#/d' "$GAME_RULE_PATH" 2>/dev/null |sed '/^ *$/d' |awk '{print "- IP-CIDR,"$0}' |awk -v tag="$2" '{print $0","'tag'""}' >> $GAME_RULE_FILE 2>/dev/null
   set_rule_file=1
}

yml_game_rule_get()
{
   local section="$1"
   local enabled group config
   config_get_bool "enabled" "$section" "enabled" "1"
   config_get "group" "$section" "group" ""
   config_get "config" "$section" "config" ""

   if [ "$enabled" = "0" ]; then
      return
   fi
   
   if [ -n "$config" ] && [ "$config" != "$CONFIG_NAME" ] && [ "$config" != "all" ]; then
      return
   fi
   
   if [ -z "$group" ]; then
      return
   fi
   
   config_list_foreach "$section" "rule_name" get_rule_file "$group"
}

yml_rule_group_get()
{
   local section="$1"
   local enabled group config
   config_get_bool "enabled" "$section" "enabled" "1"
   config_get "group" "$section" "group" ""
   config_get "config" "$section" "config" ""

   if [ "$enabled" = "0" ]; then
      return
   fi
   
   if [ -n "$config" ] && [ "$config" != "$CONFIG_NAME" ] && [ "$config" != "all" ]; then
      return
   fi
   
   if [ -z "$group" ]; then
      return
   fi
   
   /usr/share/openclash/yml_groups_set.sh >/dev/null 2>&1 "$group"
}

yml_game_custom()
{
#处理游戏规则
rm -rf $GAME_RULE_FILE 2>/dev/null
config_load "openclash"
config_foreach yml_game_rule_get "game_config"
if [ -n "$(grep "OpenClash-Game-Rules" "$RULE_FILE")" ]; then
   sed -i '/OpenClash-Game-Rules/,/OpenClash-Game-Rules-End/d' "$RULE_FILE" 2>/dev/null
fi
sed -i '/OpenClash-Game-Rules/d' "$RULE_FILE" 2>/dev/null
sed -i '/OpenClash-Game-Rules-End/d' "$RULE_FILE" 2>/dev/null
[ "$set_rule_file" = 1 ] && {
   if [ -n "$(grep "##Custom Rules 2##" "$RULE_FILE")" ]; then
      sed -i "/##Custom Rules 2##/i\#===================== OpenClash-Game-Rules =====================#" "$RULE_FILE" 2>/dev/null
   elif [ -n "$(grep "^ \{0,\}- GEOIP" "$RULE_FILE")" ]; then
      sed -i '1,/^ \{0,\}- GEOIP,/{/^ \{0,\}- GEOIP,/s/^ \{0,\}- GEOIP,/#===================== OpenClash-Game-Rules =====================#\n&/}' "$RULE_FILE" 2>/dev/null
   elif [ -n "$(grep "^ \{0,\}- MATCH," "$RULE_FILE")" ]; then
      sed -i '1,/^ \{0,\}- MATCH,/{/^ \{0,\}- MATCH,/s/^ \{0,\}- MATCH,/#===================== OpenClash-Game-Rules =====================#\n&/}' "$RULE_FILE" 2>/dev/null
   else
      echo "#===================== OpenClash-Game-Rules =====================#" >> "$RULE_FILE" 2>/dev/null
   fi
   echo "#===================== OpenClash-Game-Rules-End =====================#" >> $GAME_RULE_FILE
   sed -i '/OpenClash-Game-Rules/r/tmp/yaml_game_rule_group.yaml' "$RULE_FILE" 2>/dev/null
}

#处理游戏节点与策略组
config_load "openclash"
config_foreach yml_rule_group_get "rule_provider_config"
config_foreach yml_rule_group_get "game_config"
sed -i '/^ \{0,\}proxy-groups:/r/tmp/yaml_groups.yaml' "$GROUP_FILE" 2>/dev/null
sed -i '/^ \{0,\}Proxy:/d' /tmp/yaml_servers.yaml 2>/dev/null
sed -i '/^ \{0,\}proxy-providers:/d' /tmp/yaml_provider.yaml 2>/dev/null
if [ ! -f "$PROXY_FILE" ] && [ -f "/tmp/yaml_servers.yaml" ]; then
   echo "Proxy:" > "$PROXY_FILE" 2>/dev/null
   sed -i '/Proxy:/r/tmp/yaml_servers.yaml' "$PROXY_FILE" 2>/dev/null
elif [ -f "/tmp/yaml_servers.yaml" ] && [ -z "$(grep "^Proxy:#d" "$PROXY_FILE")" ]; then
   sed -i '/^Proxy:/r/tmp/yaml_servers.yaml' "$PROXY_FILE" 2>/dev/null
elif [ -f "/tmp/yaml_servers.yaml" ] && [ -n "$(grep "^Proxy:#d" "$PROXY_FILE")" ]; then
   sed -i '/^Proxy:#d/r/tmp/yaml_servers.yaml' "$PROXY_FILE" 2>/dev/null
fi
if [ ! -f "$PROXY_PROVIDER_FILE" ] && [ -f "/tmp/yaml_provider.yaml" ]; then
   echo "proxy-providers:" > "$PROXY_PROVIDER_FILE" 2>/dev/null
   sed -i '/proxy-providers:/r/tmp/yaml_provider.yaml' "$PROXY_PROVIDER_FILE" 2>/dev/null
elif [ -f "/tmp/yaml_servers.yaml" ]; then
   sed -i '/^proxy-providers:r/tmp/yaml_provider.yaml' "$PROXY_PROVIDER_FILE" 2>/dev/null
fi

#关键字还原
if [ -z "$(grep "^Proxy:#d" "$PROXY_FILE")" ]; then
   sed -i "s/^Proxy:/proxies:/g" "$PROXY_FILE" 2>/dev/null
else
   sed -i "s/^Proxy:#d/proxies:/g" "$PROXY_FILE" 2>/dev/null
fi

}

yml_rule_set_add()
{
   if [ -z "$(grep "rules:" "$RULE_FILE" 2>/dev/null)" ]; then
      echo "rules:" > "$RULE_FILE"
   fi
   if [ "$3" -eq 1 ]; then
      if [ -z "$(grep "OpenClash-Rule-Set-Extended-End" "$RULE_FILE" 2>/dev/null)" ]; then
         if [ -n "$(grep "##Custom Rules 2##" "$RULE_FILE")" ]; then
            sed -i "/##Custom Rules 2##/i\#===================== OpenClash-Rule-Set-Extended-End =====================#" "$RULE_FILE" 2>/dev/null
            sed -i "/OpenClash-Rule-Set-Extended-End/i\#===================== OpenClash-Rule-Set-Extended =====================#" "$RULE_FILE" 2>/dev/null
         elif [ -n "$(grep "^ \{0,\}- GEOIP" "$RULE_FILE")" ]; then
            sed -i '1,/^ \{0,\}- GEOIP,/{/^ \{0,\}- GEOIP,/s/^ \{0,\}- GEOIP,/#===================== OpenClash-Rule-Set-Extended-End =====================#\n&/}' "$RULE_FILE" 2>/dev/null
            sed -i "/OpenClash-Rule-Set-Extended-End/i\#===================== OpenClash-Rule-Set-Extended =====================#" "$RULE_FILE" 2>/dev/null
         elif [ -n "$(grep "^ \{0,\}- MATCH," "$RULE_FILE")" ]; then
            sed -i '1,/^ \{0,\}- MATCH,/{/^ \{0,\}- MATCH,/s/^ \{0,\}- MATCH,/#===================== OpenClash-Rule-Set-Extended-End =====================#\n&/}' "$RULE_FILE" 2>/dev/null
            sed -i "/OpenClash-Rule-Set-Extended-End/i\#===================== OpenClash-Rule-Set-Extended =====================#" "$RULE_FILE" 2>/dev/null
         else
            echo "#===================== OpenClash-Rule-Set-Extended =====================#" >> "$RULE_FILE" 2>/dev/null
            echo "#===================== OpenClash-Rule-Set-Extended-End =====================#" >> "$RULE_FILE" 2>/dev/null
         fi
      fi
      sed -i "/OpenClash-Rule-Set-Extended-End/i\- RULE-SET,${1},${2}" "$RULE_FILE" 2>/dev/null
  elif [ "$3" -eq 0 ]; then
     if [ -z "$(grep "OpenClash-Rule-Set-Priority-End" "$RULE_FILE" 2>/dev/null)" ]; then
        if [ -n "$(grep "##Custom Rules##" "$RULE_FILE" 2>/dev/null)" ]; then
           sed -i "/##Custom Rules End##/a\#===================== OpenClash-Rule-Set-Priority-End =====================#" "$RULE_FILE" 2>/dev/null
           sed -i "/##Custom Rules End##/a\#===================== OpenClash-Rule-Set-Priority =====================#" "$RULE_FILE" 2>/dev/null
        else
           sed -i "/^rules:/a\#===================== OpenClash-Rule-Set-Priority-End =====================#" "$RULE_FILE" 2>/dev/null
           sed -i "/^rules:/a\#===================== OpenClash-Rule-Set-Priority =====================#" "$RULE_FILE" 2>/dev/null
        fi
     fi
     sed -i "/OpenClash-Rule-Set-Priority-End/i\- RULE-SET,${1},${2}" "$RULE_FILE" 2>/dev/null
  fi
}

yml_gen_rule_provider_file()
{
   if [ -z "$1" ]; then
      return
   fi
   
   RULE_PROVIDER_FILE_NAME=$(grep "^$1," /usr/share/openclash/res/rule_providers.list |awk -F ',' '{print $6}' 2>/dev/null)
   if [ -z "$RULE_PROVIDER_FILE_NAME" ]; then
      RULE_PROVIDER_FILE_NAME=$(grep "^$1," /usr/share/openclash/res/rule_providers.list |awk -F ',' '{print $5}' 2>/dev/null)
   fi
   RULE_PROVIDER_FILE_BEHAVIOR=$(grep ",$RULE_PROVIDER_FILE_NAME$" /usr/share/openclash/res/rule_providers.list |awk -F ',' '{print $3}' 2>/dev/null)
   RULE_PROVIDER_FILE_PATH="/etc/openclash/rule_provider/$RULE_PROVIDER_FILE_NAME"
   RULE_PROVIDER_FILE_URL_PATH="$(grep ",$RULE_PROVIDER_FILE_NAME$" /usr/share/openclash/res/rule_providers.list |awk -F ',' '{print $4$5}' 2>/dev/null)"
   RULE_PROVIDER_FILE_URL="https://cdn.jsdelivr.net/gh/"$(echo "$RULE_PROVIDER_FILE_URL_PATH" |awk -F '/master' '{print $1}' 2>/dev/null)"@master"$(echo "$RULE_PROVIDER_FILE_URL_PATH" |awk -F 'master' '{print $2}')""
   if [ -n "$(grep "$RULE_PROVIDER_FILE_URL" $RULE_PROVIDER_FILE 2>/dev/null)" ]; then
      return
   fi

   if [ -z "$(grep "rule-providers:" $RULE_PROVIDER_FILE 2>/dev/null)" ]; then
      echo "rule-providers:" > "$RULE_PROVIDER_FILE"
   fi

   if [ -z "$(grep "OpenClash-Rule-Providers-Set" $RULE_PROVIDER_FILE 2>/dev/null)" ]; then
      echo "#===================== OpenClash-Rule-Providers-Set =====================#" >> "$RULE_PROVIDER_FILE"
   fi

cat >> "$RULE_PROVIDER_FILE" <<-EOF
  $1:
    type: http
    behavior: $RULE_PROVIDER_FILE_BEHAVIOR
    path: $RULE_PROVIDER_FILE_PATH
    url: $RULE_PROVIDER_FILE_URL
EOF
   if [ -z "$3" ]; then
cat >> "$RULE_PROVIDER_FILE" <<-EOF
    interval=86400
EOF
   else
cat >> "$RULE_PROVIDER_FILE" <<-EOF
    interval: $3
EOF
   fi
   yml_rule_set_add "$1" "$2" "$4"
}

yml_get_rule_provider()
{
   local section="$1"
   local enabled group config interval position
   config_get_bool "enabled" "$section" "enabled" "1"
   config_get "group" "$section" "group" ""
   config_get "config" "$section" "config" ""
   config_get "interval" "$section" "interval" ""
   config_get "position" "$section" "position" ""

   if [ "$enabled" = "0" ]; then
      return
   fi
   
   if [ -n "$config" ] && [ "$config" != "$CONFIG_NAME" ] && [ "$config" != "all" ]; then
      return
   fi

   if [ -z "$group" ]; then
      return
   fi
   
   config_list_foreach "$section" "rule_name" yml_gen_rule_provider_file "$group" "$interval" "$position"
}

#处理自定义规则集
yml_set_custom_rule_provider()
{
   local section="$1"
   local enabled name config type behavior path url interval group position
   config_get_bool "enabled" "$section" "enabled" "1"
   config_get "name" "$section" "name" ""
   config_get "config" "$section" "config" ""
   config_get "type" "$section" "type" ""
   config_get "behavior" "$section" "behavior" ""
   config_get "path" "$section" "path" ""
   config_get "url" "$section" "url" ""
   config_get "interval" "$section" "interval" ""
   config_get "group" "$section" "group" ""
   config_get "position" "$section" "position" ""

   if [ "$enabled" = "0" ]; then
      return
   fi

   if [ -n "$(grep "$url" "$RULE_PROVIDER_FILE" 2>/dev/null)" ] && [ -n "$url" ]; then
      return
   fi
   
   if [ -n "$config" ] && [ "$config" != "$CONFIG_NAME" ] && [ "$config" != "all" ]; then
      return
   fi
   
   if [ -z "$name" ] || [ -z "$type" ] || [ -z "$behavior" ]; then
      return
   fi

   if [ "$type" = "http" ] && [ -z "$url" ]; then
      return
   fi

   if [ "$path" != "./rule_provider/$name.yaml" ] && [ "$type" = "http" ]; then
      path="./rule_provider/$name.yaml"
   elif [ -z "$path" ]; then
      return
   fi
  
  if [ -n "$(grep "$path" "$RULE_PROVIDER_FILE" 2>/dev/null)" ]; then
      return
   fi

   if [ -z "$interval" ] && [ "$type" = "http" ]; then
      interval=86400
   fi

   if [ -z "$(grep "rule-providers:" "$RULE_PROVIDER_FILE" 2>/dev/null)" ]; then
      echo "rule-providers:" > "$RULE_PROVIDER_FILE"
   fi

   if [ -z "$(grep "OpenClash-Rule-Providers-Set" "$RULE_PROVIDER_FILE" 2>/dev/null)" ]; then
      echo "#===================== OpenClash-Rule-Providers-Set =====================#" >> "$RULE_PROVIDER_FILE"
   fi

cat >> "$RULE_PROVIDER_FILE" <<-EOF
  $name:
    type: $type
    behavior: $behavior
    path: $path
EOF
    if [ "$type" = "http" ]; then
cat >> "$RULE_PROVIDER_FILE" <<-EOF
    url: $url
    interval: $interval
EOF
    fi

   yml_rule_set_add "$name" "$group" "$position"
}

#处理规则集
yml_custom_rule_provider()
{

   if [ -n "$(grep "OpenClash-Rule-Set-Extended-End" "$RULE_FILE")" ]; then
      sed -i '/OpenClash-Rule-Set-Extended/,/OpenClash-Rule-Set-Extended-End/d' "$RULE_FILE" 2>/dev/null
   fi

   if [ -n "$(grep "OpenClash-Rule-Set-Priority-End" "$RULE_FILE")" ]; then
      sed -i '/OpenClash-Rule-Set-Priority/,/OpenClash-Rule-Set-Priority-End/d' "$RULE_FILE" 2>/dev/null
   fi

   if [ -n "$(grep "OpenClash-Rule-Providers-Set" "$RULE_PROVIDER_FILE" 2>/dev/null)" ]; then
      sed -i '/OpenClash-Rule-Providers-Set/,/OpenClash-Rule-Providers-Set-End/d' "$RULE_PROVIDER_FILE" 2>/dev/null
   fi

   sed -i '/OpenClash-Rule-Set/d' "$RULE_FILE" 2>/dev/null
   sed -i '/OpenClash-Rule-Providers/d' "$RULE_PROVIDER_FILE" 2>/dev/null

   if [ -z "$(grep "^    type:" $RULE_PROVIDER_FILE 2>/dev/null)" ]; then
      #处理缩进
      sed -i '/^ *$/d' "$RULE_PROVIDER_FILE" 2>/dev/null
      sed -i 's/\t/ /g' "$RULE_PROVIDER_FILE" 2>/dev/null
      sed -i 's/^ \{1,\}/  /g' "$RULE_PROVIDER_FILE" 2>/dev/null
      sed -i 's/^ \{1,\}type:/    type:/g' "$RULE_PROVIDER_FILE" 2>/dev/null
      sed -i 's/^ \{1,\}behavior:/    behavior:/g' "$RULE_PROVIDER_FILE" 2>/dev/null
      sed -i 's/^ \{1,\}path:/    path:/g' "$RULE_PROVIDER_FILE" 2>/dev/null
      sed -i 's/^ \{1,\}url:/    url:/g' "$RULE_PROVIDER_FILE" 2>/dev/null
      sed -i 's/^ \{1,\}interval:/    interval:/g' "$RULE_PROVIDER_FILE" 2>/dev/null
      sed -i 's/^ \{1,\}rule-providers:/rule-providers:/g' "$RULE_PROVIDER_FILE" 2>/dev/null
   fi

   config_load "openclash"
   config_foreach yml_get_rule_provider "rule_provider_config"
   config_foreach yml_set_custom_rule_provider "rule_providers"

   if [ -n "$(grep "OpenClash-Rule-Providers-Set" $RULE_PROVIDER_FILE 2>/dev/null)" ]; then
      echo "#===================== OpenClash-Rule-Providers-Set-End =====================#" >> "$RULE_PROVIDER_FILE"
   fi

}

#配置文件选择
config_choose()
{
if [ -z "$CONFIG_FILE" ] || [ ! -f "$CONFIG_FILE" ]; then
   CONFIG_NAME=$(ls -lt /etc/openclash/config/ | grep -E '.yaml|.yml' | head -n 1 |awk '{print $9}')
   if [ -n "$CONFIG_NAME" ]; then
      uci set openclash.config.config_path="/etc/openclash/config/$CONFIG_NAME"
      uci commit openclash
      CONFIG_FILE="/etc/openclash/config/$CONFIG_NAME"
   elif [ -f "/etc/openclash/config.yaml" ]; then
      mv "/etc/openclash/config.yaml" "/etc/openclash/config/config.yaml"
      uci set openclash.config.config_path="/etc/openclash/config/config.yaml"
      uci commit openclash
      CONFIG_FILE="/etc/openclash/config/config.yaml"
   elif [ -f "/etc/openclash/config.yml" ]; then
      mv "/etc/openclash/config.yml" "/etc/openclash/config/config.yaml"
      uci set openclash.config.config_path="/etc/openclash/config/config.yaml"
      uci commit openclash
      CONFIG_FILE="/etc/openclash/config/config.yaml"
   fi
else
   if [ ! -f "$CONFIG_FILE" ] && [ -f "$BACKUP_FILE" ]; then
      cp "$BACKUP_FILE" "$CONFIG_FILE"
   fi
fi 2>/dev/null
CONFIG_NAME=$(echo "$CONFIG_FILE" |awk -F '/' '{print $5}' 2>/dev/null)

if [ ! -f "$CONFIG_FILE" ]; then
   subscribe_info=$(uci get openclash.@config_subscribe[0].address 2>/dev/null)
   if [ ! -f "$CONFIG_FILE" ] && [ -n "$subscribe_info" ]; then
      echo "配置文件不存在，您已设置订阅信息，准备开始下载..." >$START_LOG
      sleep 3
      kill_clash
      nohup /usr/share/openclash/openclash.sh &
      exit 0
   elif [ ! -f "$CONFIG_FILE" ]; then
      echo "错误: 缺少配置文件，请上传或更新配置文件！" >$START_LOG
      echo "${LOGTIME} Error: Config Not Found" >> $LOG_FILE
      sleep 5
      exit 0
   fi
fi
}

#运行模式处理
do_run_mode()
{
   en_mode=$(uci get openclash.config.en_mode 2>/dev/null)
  
   if [ "$en_mode" = "fake-ip-tun" ]; then
      en_mode_tun="1"
      en_mode="fake-ip"
   fi
    
   if [ "$en_mode" = "redir-host-tun" ]; then
      en_mode_tun="1"
      en_mode="redir-host"
   fi
    
   if [ "$en_mode" = "redir-host-mix" ]; then
      en_mode_tun="3"
      en_mode="redir-host"
   fi
    
   if [ "$en_mode" = "redir-host-vpn" ]; then
      en_mode_tun="2"
      en_mode="redir-host"
   fi
    
   if [ "$en_mode" = "fake-ip-vpn" ]; then
      en_mode_tun="2"
      en_mode="fake-ip"
   fi
    
   if [ "$en_mode" = "fake-ip-mix" ]; then
      en_mode_tun="3"
      en_mode="fake-ip"
   fi
}

do_run_file()
{

   if [ "$small_flash_memory" != "1" ]; then
      dev_core_path="/etc/openclash/core/clash"
      tun_core_path="/etc/openclash/core/clash_tun"
      game_core_path="/etc/openclash/core/clash_game"
      geoip_path="/etc/openclash/Country.mmdb"
   else
      dev_core_path="/tmp/etc/openclash/core/clash"
      tun_core_path="/tmp/etc/openclash/core/clash_tun"
      game_core_path="/tmp/etc/openclash/core/clash_game"
      geoip_path="/tmp/etc/openclash/Country.mmdb"
   fi
    
   rm -rf "/etc/openclash/clash" 2>/dev/null
    
   if [ "$en_mode_tun" = "1" ] || [ "$en_mode_tun" = "3" ]; then
      ln -s "$tun_core_path" /etc/openclash/clash 2>/dev/null
      core_type="Tun"
      core_start_log="检测到配置了【Tun】内核专属功能，调用【Tun】内核启动..."
   fi
    
   if [ "$en_mode_tun" = "2" ]; then
      ln -s "$game_core_path" /etc/openclash/clash 2>/dev/null
      core_type="Game"
      core_start_log="检测到配置了【Game】内核专属功能，调用【Game】内核启动..."
   fi

   if [ "$proxy_mode" = "script" ] || [ "$rule_source" = "ConnersHua" ] || [ "$rule_source" = "lhie1" ] || [ -n "$(grep "^ \{0,\}- RULE-SET," "$CONFIG_FILE" 2>/dev/null)" ]; then
      rm -rf "/etc/openclash/clash" 2>/dev/null
      ln -s "$tun_core_path" /etc/openclash/clash 2>/dev/null
      core_type="Tun"
      core_start_log="检测到配置了【Tun】内核专属功能，调用【Tun】内核启动..."
   fi
    
   if [ ! -f "/etc/openclash/clash" ] && [ -f "$dev_core_path" ] && [ -z "$core_type" ]; then
      ln -s "$dev_core_path" /etc/openclash/clash 2>/dev/null
      core_start_log="未检测到特殊配置，调用【Dev】内核启动..."
   fi
    
   if [ ! -f "/etc/openclash/clash" ] && [ -f "$tun_core_path" ] && [ "$core_type" != "Game" ]; then
      ln -s "$tun_core_path" /etc/openclash/clash 2>/dev/null
      core_type="Tun"
      core_start_log="检测到【Dev】内核未安装，调用【Tun】内核启动..."
   fi
    
   if [ ! -f "/etc/openclash/clash" ] && [ -f "$game_core_path" ] && [ "$core_type" != "Tun" ]; then
      ln -s "$game_core_path" /etc/openclash/clash 2>/dev/null
      core_type="Game"
      core_start_log="检测到【Dev】内核未安装，调用【Game】内核启动..."
   fi

#权限检查
   [ ! -x "$tun_core_path" ] && chmod 4755 "$tun_core_path" 2>/dev/null
   [ ! -x "$game_core_path" ] && chmod 4755 "$game_core_path" 2>/dev/null
   [ ! -x "$dev_core_path" ] && chmod 4755 "$dev_core_path" 2>/dev/null
   
   [ -f "$geoip_path" ] && [ "$small_flash_memory" = "1" ] && {
      rm -rf "/etc/openclash/Country.mmdb" 2>/dev/null
      ln -s "$geoip_path" /etc/openclash/Country.mmdb 2>/dev/null
   }
   
   [ ! -f "$geoip_path" ] && {
     echo "检测到GEOIP数据库文件不存在，准备开始下载..." >$START_LOG
     sleep 3
     kill_clash
     nohup /usr/share/openclash/openclash_ipdb.sh &
     exit 0
   }
   
   [ ! -f "$CLASH" ] && {
     echo "检测到内核文件不存在，准备开始下载..." >$START_LOG
     sleep 3
     rm -rf "/tmp/clash_last_version" 2>/dev/null
     kill_clash
     nohup /usr/share/openclash/openclash_core.sh "$core_type" &
     exit 0
   }
   
   if ! capsh --is-uid=0 >/dev/null || ! capsh --has-ambient >/dev/null; then
     echo "错误：Capsh异常，请尝试重新安装依赖【libcap】和相应的Capsh库，终止启动..." >$START_LOG
     echo "${LOGTIME} Error: Could Not Load The Capsh Library, Please Verify The Capsh Shell Library Work Well" >> $LOG_FILE
     echo "${LOGTIME} Tip: You Could Download And Re-Install The libcap & libcap-bin Library From The Address Below:" >> $LOG_FILE
     echo "" >> $LOG_FILE
     echo "---------- https://mirrors.cloud.tencent.com/lede/snapshots/packages/ ----------" >> $LOG_FILE
     echo "" >> $LOG_FILE
     sleep 5
     start_fail
   fi

}

#绑定interface防止回环
check_interface_name()
{
	interface_name=$(ip route |grep "default" |awk '{print $5}' 2>/dev/null)
	if [ -z "$(grep "^interface-name: $interface_name" "$CONFIG_FILE" 2>/dev/null)" ] && [ -n "$interface_name" ]; then
    if [ ! -z "$(grep "^ \{0,\}interface-name:" "$CONFIG_FILE" 2>/dev/null)" ]; then
       sed -i "/^ \{0,\}interface-name:/c\interface-name: ${interface_name}" "$CONFIG_FILE" 2>/dev/null
    else
       sed -i "/^redir-port:/a\interface-name: ${interface_name}" "$CONFIG_FILE" 2>/dev/null
    fi
  fi
}

start_run_core()
{
   echo "$core_start_log" >$START_LOG
   sleep 2
   ulimit -SHn 65535 2>/dev/null
   ulimit -v unlimited 2>/dev/null
   modprobe tun >/dev/null 2>&1
   check_interface_name
   config_reload=$(uci get openclash.config.config_reload 2>/dev/null)
   if [ -n "$(pidof clash)" ] && [ "$core_type" != "Tun" ] && [ "$config_reload" != "0" ]; then
      curl -s --connect-timeout 5 -m 5 -H 'Content-Type: application/json' -H "Authorization: Bearer ${da_password}" -XPUT http://"$lan_ip":"$cn_port"/configs -d "{\"path\": \"$CONFIG_FILE\"}" 2>/dev/null
   else
      kill_clash
      #防止赋权失败
      touch /tmp/openclash.log 2>/dev/null
      chmod o+w /etc/openclash/proxy_provider/* 2>/dev/null
      chmod o+w /etc/openclash/rule_provider/* 2>/dev/null
      chmod o+w /tmp/openclash.log 2>/dev/null
      chown nobody:nogroup /etc/openclash/core/* 2>/dev/null
      #使用nobody启动内核方便代理路由自身流量
      capabilties="cap_sys_resource,cap_dac_override,cap_net_raw,cap_net_bind_service,cap_net_admin"
      capsh --caps="${capabilties}+eip" -- -c "capsh --user=nobody --addamb='${capabilties}' -- -c 'nohup $CLASH -d $CLASH_CONFIG -f \"$CONFIG_FILE\" >> $LOG_FILE 2>&1 &'" >> $LOG_FILE 2>&1
   fi
   uci set openclash.config.config_reload=1 2>/dev/null
   uci commit openclash
}

check_core_status()
{
   check_time=1
   while ( [ "$check_time" -le 3 ] && [ -n "$(pidof clash)" ] )
   do
      sleep 1
      check_time=$(expr "$check_time" + 1)
   done
}

#不修改配置文件启动
raw_config_start()
{
   mv "$START_BACKUP" "$CONFIG_FILE"
   dns_port=$(grep "^ \{0,\}listen:" "$CONFIG_FILE" |awk -F ':' '{print $3}' |awk -F '#' '{print $1}' |tr -cd "[0-9]" 2>/dev/null)
   en_mode=$(grep "^ \{0,\}enhanced-mode:" "$CONFIG_FILE" |awk -F ': ' '{print $2}' |awk -F '#' '{print $1}' 2>/dev/null |sed 's/^ \{0,\}//g' 2>/dev/null |sed 's/ \{0,\}$//g' 2>/dev/null)
   proxy_port=$(grep "^ \{0,\}redir-port:" "$CONFIG_FILE" |awk -F ': ' '{print $2}' |awk -F '#' '{print $1}' 2>/dev/null |tr -cd "[0-9]")
   
   if [ -z "$dns_port" ] || [ -z "$en_mode" ] || [ -z "$proxy_port" ]; then
      if [ -z "$dns_port" ]; then
         echo "错误: 无法获取DNS部分的监听端口设置, OpenClash 使用原始配置文件启动失败" >$START_LOG
         echo "${LOGTIME} Error: Get DNS 'listen' Option Error, OpenClash Can Not Start With Raw Config File" >> $LOG_FILE
         sleep 3
      fi
      if [ -z "$en_mode" ]; then
         echo "错误: 无法获取DNS部分的运行模式设置, OpenClash 使用原始配置文件启动失败" >$START_LOG
         echo "${LOGTIME} Error: Get DNS 'enhanced-mode' Option Error, OpenClash Can Not Start With Raw Config File" >> $LOG_FILE
         sleep 3
      fi
      if [ -z "$proxy_port" ]; then
         echo "错误: 无法获取General部分的转发端口设置, OpenClash 使用原始配置文件启动失败" >$START_LOG
         echo "${LOGTIME} Error: Get General 'redir-port' Option Error, OpenClash Can Not Start With Raw Config File" >> $LOG_FILE
         sleep 3
      fi
      start_fail
   fi
   
   start_run_core
   check_core_status
   
   if ! pidof clash >/dev/null; then
      echo "错误: OpenClash 启动失败，请到日志页面查看详细错误信息！" >$START_LOG
      echo "${LOGTIME} Error: OpenClash Can Not Start, Please Check The Error Info And Try Again" >> $LOG_FILE
      sleep 5
      start_fail
   fi
   
   if [ "$en_mode" = "redir-host" ]; then
      case $en_mode_tun in
      "1")
         uci set openclash.config.en_mode=redir-host-tun
      ;;
      "2")
         uci set openclash.config.en_mode=redir-host-vpn
      ;;
      "3")
         uci set openclash.config.en_mode=redir-host-mix
      ;;
      *)
         uci set openclash.config.en_mode=redir-host
      esac
   elif [ "$en_mode" = "fake-ip" ]; then
   	  case $en_mode_tun in
      "1")
         uci set openclash.config.en_mode=fake-ip-tun
      ;;
      "2")
         uci set openclash.config.en_mode=fake-ip-vpn
      ;;
      "3")
         uci set openclash.config.en_mode=fake-ip-mix
      ;;
      *)
         uci set openclash.config.en_mode=fake-ip
      esac
   fi
   
   dase=$(grep "^ \{0,\}Secret:" "$CONFIG_FILE" |awk -F ': ' '{print $2}' |awk -F '#' '{print $1}' |sed 's/^ \{0,\}//g' 2>/dev/null |sed 's/ \{0,\}$//g' 2>/dev/null |sed "s/\'//g" 2>/dev/null |sed "s/\'//g" 2>/dev/null)
   uci set openclash.config.dashboard_password="$dase" 2>/dev/null
   
   cn_port=$(grep "^ \{0,\}external-controller:" "$CONFIG_FILE" |awk -F ':' '{print $3}' |awk -F '#' '{print $1}' |tr -cd "[0-9]" 2>/dev/null)
   uci set openclash.config.cn_port="$cn_port" 2>/dev/null
   
   uci set openclash.config.proxy_port="$proxy_port"
   uci set openclash.config.restricted_mode=1
   
   uci commit openclash
}

try_restore_start()
{
   if [ -z "$(pidof clash)" ]; then
      if [ "$rule_source" = 0 ] && [ "$enable_custom_clash_rules" = 0 ]; then
         echo "错误: OpenClash 启动失败，尝试使用原始配置文件启动..." >$START_LOG
         echo "${LOGTIME} Error: OpenClash Can Not Start, Try Use Raw Config Restart Again" >> $LOG_FILE
         sleep 3
         raw_config_start
      else
         echo "错误: OpenClash 启动失败，尝试还原第三方规则并重新启动 Clash 主程序..." >$START_LOG
         echo "${LOGTIME} Error: OpenClash Can Not Start, Try Use Backup Rules Start Again" >> $LOG_FILE
         rm -rf /tmp/yaml_general 2>/dev/null
         #获取备份rule_provider
         rule_provider_bak_len=$(sed -n '/^rule-providers:/=' "$START_BACKUP" 2>/dev/null)
         if [ -n "$rule_provider_bak_len" ]; then
            /usr/share/openclash/yml_field_cut.sh "$rule_provider_bak_len" "$RULE_PROVIDER_BAK_FILE" "$START_BACKUP"
         fi 2>/dev/null
         #获取备份script
         script_bak_len=$(sed -n '/^script:/=' "$START_BACKUP" 2>/dev/null)
         if [ -n "$script_bak_len" ]; then
            /usr/share/openclash/yml_field_cut.sh "$script_bak_len" "$SCRIPT_BAK_FILE" "$START_BACKUP"
         fi 2>/dev/null
         #获取备份rule
         rule_bak_len=$(sed -n '/^rules:/=' "$START_BACKUP" 2>/dev/null)
         if [ -n "$rule_bak_len" ]; then
            /usr/share/openclash/yml_field_cut.sh "$rule_bak_len" "$RULE_BAK_FILE" "$START_BACKUP"
         fi 2>/dev/null
         yml_rule_bak_merge
         start_run_core
         check_core_status
         if ! pidof clash >/dev/null; then
            echo "错误: OpenClash 启动失败，尝试使用原始配置文件启动..." >$START_LOG
            echo "${LOGTIME} Error: OpenClash Can Not Start, Try Use Raw Config Restart Again" >> $LOG_FILE
            sleep 3
            raw_config_start
         fi
      fi
   fi
}

#防火墙设置部分
ac_add()
{
   if [ -z "$1" ]; then
      return
   fi
  
   ipset add "$2" "$1" 2>/dev/null
}

firewall_rule_exclude()
{
   local section="$1"
   local name src src_port dest dest_port proto target enabled

   config_get "name" "$section" "name" ""
   config_get "src" "$section" "src" ""
   config_get "src_port" "$section" "src_port" ""
   config_get "dest" "$section" "dest" ""
   config_get "dest_port" "$section" "dest_port" ""
   config_get "proto" "$section" "proto" ""
   config_get "target" "$section" "target" ""
   config_get "enabled" "$section" "enabled" ""

   if [ a"$target" != aACCEPT  ] || [ a"$enabled" == a0 ]; then
      return
   fi

   local e_udp=false
   local e_tcp=false
   for p in $proto; do
       if [ $p == tcp ]; then e_tcp=true; fi
       if [ $p == udp ]; then e_udp=true; fi
   done

   if ! $e_udp && ! $e_tcp ; then
       return
   fi

   if [ -z "$en_mode_tun" ] || [ "$en_mode_tun" -eq 3 ]; then
      if $e_tcp ; then
          iptables -t nat -I openclash_output -p tcp --sport "$dest_port" -j RETURN >/dev/null 2>&1
      fi
      if $e_udp ; then
          iptables -t mangle -I openclash_output -p udp --sport "$dest_port" -j RETURN >/dev/null 2>&1
          iptables -t mangle -I openclash -p udp --dport "$dest_port" -j RETURN >/dev/null 2>&1
      fi
   elif [ "$en_mode_tun" -ne 3 ]; then
      if $e_tcp ; then
          iptables -t mangle -I openclash_output -p tcp --sport "$dest_port" -j RETURN >/dev/null 2>&1
          iptables -t mangle -I openclash -p tcp --dport "$dest_port" -j RETURN >/dev/null 2>&1
      fi
      if $e_udp ; then
          iptables -t mangle -I openclash_output -p udp --sport "$dest_port" -j RETURN >/dev/null 2>&1
          iptables -t mangle -I openclash -p udp --dport "$dest_port" -j RETURN >/dev/null 2>&1
      fi
   fi
}

firewall_redirect_exclude()
{
   local section="$1"
   local src_dport
   config_get "src_dport" "$section" "src_dport" ""
   
   if [ -z "$src_dport" ]; then
      return
   fi

   if [ -z "$en_mode_tun" ] || [ "$en_mode_tun" -eq 3 ]; then
   	  iptables -t nat -I openclash_output -p tcp --sport "$src_dport" -j RETURN >/dev/null 2>&1
   	  iptables -t mangle -I openclash_output -p udp --sport "$src_dport" -j RETURN >/dev/null 2>&1
      iptables -t mangle -I openclash -p udp --dport "$src_dport" -j RETURN >/dev/null 2>&1
   elif [ "$en_mode_tun" -ne 3 ]; then
   	  iptables -t mangle -I openclash_output -p tcp --sport "$src_dport" -j RETURN >/dev/null 2>&1
   	  iptables -t mangle -I openclash_output -p udp --sport "$src_dport" -j RETURN >/dev/null 2>&1
      iptables -t mangle -I openclash -p tcp --dport "$src_dport" -j RETURN >/dev/null 2>&1
      iptables -t mangle -I openclash -p udp --dport "$src_dport" -j RETURN >/dev/null 2>&1
   fi

}

set_firewall()
{
if [ "$(iptables -t nat -nL PREROUTING --line-number |grep "udp dpt:53" |grep "0.0.0.0/0 \{0,\}0.0.0.0/0" |wc -l)" -gt 1 ] && [ "$enable_redirect_dns" -eq "1" ]; then
   echo "发现53端口被劫持，清理防火墙规则..." >$START_LOG
   pre_lines=$(iptables -nvL PREROUTING -t nat |sed 1,2d |sed -n '/0.0.0.0\/0 \{0,\}0.0.0.0\/0 \{0,\}udp dpt:53/=' 2>/dev/null |sort -rn)
   for pre_line in $pre_lines; do
      iptables -t nat -D PREROUTING "$pre_line" >/dev/null 2>&1
   done
   iptables -t nat -A PREROUTING -p udp --dport 53 -j REDIRECT --to-ports 53 >/dev/null 2>&1
   sleep 2
fi

if [ -z "$(uci get firewall.openclash 2>/dev/null)" ] || [ -z "$(uci get ucitrack.@openclash[-1].init 2>/dev/null)" ]; then
   uci delete ucitrack.@openclash[-1] >/dev/null 2>&1
   uci add ucitrack openclash >/dev/null 2>&1
   uci set ucitrack.@openclash[-1].init=openclash >/dev/null 2>&1
   uci commit ucitrack >/dev/null 2>&1
   uci delete firewall.openclash >/dev/null 2>&1
   uci set firewall.openclash=include >/dev/null 2>&1
   uci set firewall.openclash.type=script >/dev/null 2>&1
   uci set firewall.openclash.path=/var/etc/openclash.include >/dev/null 2>&1
   uci set firewall.openclash.reload=1 >/dev/null 2>&1
fi
          
if [ "$(uci get firewall.@defaults[0].forward)" != "ACCEPT" ]; then
   uci set firewall.@defaults[0].forward=ACCEPT >/dev/null 2>&1
   uci commit firewall >/dev/null 2>&1
   /etc/init.d/firewall reload >/dev/null 2>&1
fi

mkdir -p /var/etc
cat > "/var/etc/openclash.include" <<-EOF
/etc/init.d/openclash reload >/dev/null 2>&1
EOF

if [ "$china_ip_route" = "1" ]; then
   if [ ! -f "/usr/share/openclash/res/china_ip_route.ipset" ]; then
      cp /etc/openclash/rule_provider/ChinaIP.yaml /tmp/china_ip_route.list 2>/dev/null
      sed -i "s/'//g" /tmp/china_ip_route.list 2>/dev/null
      sed -i "s/^ \{0,\}- //g" /tmp/china_ip_route.list 2>/dev/null
      sed -i '/payload:/d' /tmp/china_ip_route.list 2>/dev/null
      sed -i '/^ \{0,\}#/d' /tmp/china_ip_route.list 2>/dev/null
      echo "create china_ip_route hash:net family inet hashsize 1024 maxelem 65536" >/usr/share/openclash/res/china_ip_route.ipset
      awk '!/^$/&&!/^#/{printf("add china_ip_route %s'" "'\n",$0)}' /tmp/china_ip_route.list >>/usr/share/openclash/res/china_ip_route.ipset
      rm -rf /tmp/china_ip_route.list 2>/dev/null
   fi
   ipset -! flush china_ip_route 2>/dev/null
   ipset -! restore </usr/share/openclash/res/china_ip_route.ipset 2>/dev/null
fi

#lan_ac
if [ "$operation_mode" = "redir-host" ] && [ "$en_mode" = "redir-host" ]; then
   if [ "$lan_ac_mode" = "0" ]; then
      if [ -n "$(uci get openclash.config.lan_ac_black_ips 2>/dev/null)" ]; then
         ipset create lan_ac_black_ips hash:net
         config_load "openclash"
         config_list_foreach "config" "lan_ac_black_ips" ac_add "lan_ac_black_ips"
      fi
      if [ -n "$(uci get openclash.config.lan_ac_black_macs 2>/dev/null)" ]; then
         ipset create lan_ac_black_macs hash:mac
         config_load "openclash"
         config_list_foreach "config" "lan_ac_black_macs" ac_add "lan_ac_black_macs"
      fi
   elif [ "$lan_ac_mode" = "1" ]; then
      if [ -n "$(uci get openclash.config.lan_ac_white_ips 2>/dev/null)" ]; then
         ipset create lan_ac_white_ips hash:net
         config_load "openclash"
         config_list_foreach "config" "lan_ac_white_ips" ac_add "lan_ac_white_ips"
      fi
      if [ -n "$(uci get openclash.config.lan_ac_white_macs 2>/dev/null)" ]; then
         ipset create lan_ac_white_macs hash:mac
         config_load "openclash"
         config_list_foreach "config" "lan_ac_white_macs" ac_add "lan_ac_white_macs"
      fi
   fi
fi

#wan ac
if [ -n "$(uci get openclash.config.wan_ac_black_ips 2>/dev/null)" ]; then
   ipset create wan_ac_black_ips hash:net
   config_load "openclash"
   config_list_foreach "config" "wan_ac_black_ips" ac_add "wan_ac_black_ips"
fi

#local
   ipset create localnetwork hash:net
   ipset add localnetwork 0.0.0.0/8
   ipset add localnetwork 127.0.0.0/8
   ipset add localnetwork 10.0.0.0/8
   ipset add localnetwork 169.254.0.0/16
   ipset add localnetwork 192.168.0.0/16
   ipset add localnetwork 224.0.0.0/4
   ipset add localnetwork 240.0.0.0/4
   ipset add localnetwork 172.16.0.0/12

   if [ -n "$wan_ip4" ]; then
      for wan_ip4s in $wan_ip4; do
         ipset add localnetwork "$wan_ip4s" 2>/dev/null
      done
   fi

if [ -z "$en_mode_tun" ] || [ "$en_mode_tun" -eq 3 ]; then
   #tcp
   iptables -t nat -N openclash
   iptables -t nat -F openclash
   iptables -t nat -A openclash -m set --match-set localnetwork dst -j RETURN
   iptables -t nat -A openclash -m set --match-set wan_ac_black_ips dst -j RETURN >/dev/null 2>&1
   iptables -t nat -A openclash -m set --match-set lan_ac_black_ips src -j RETURN >/dev/null 2>&1
   iptables -t nat -A openclash -m set --match-set lan_ac_black_macs src -j RETURN >/dev/null 2>&1
   iptables -t nat -A openclash -m set ! --match-set lan_ac_white_macs src -j RETURN >/dev/null 2>&1
   iptables -t nat -A openclash -m set ! --match-set lan_ac_white_ips src -j RETURN >/dev/null 2>&1
   if [ "$en_mode" = "redir-host" ]; then
      iptables -t nat -A openclash -m set --match-set china_ip_route dst -j RETURN >/dev/null 2>&1
   fi
   iptables -t nat -A openclash -p tcp -j REDIRECT --to-ports "$proxy_port"
   if [ -z "$en_mode_tun" ]; then
      iptables -t nat -I PREROUTING -p tcp -d 8.8.8.8 -j REDIRECT --to-ports "$proxy_port"
      iptables -t nat -I PREROUTING -p tcp -d 8.8.4.4 -j REDIRECT --to-ports "$proxy_port"
   fi
   iptables -t nat -A PREROUTING -p tcp -j openclash
   if [ -z "$en_mode_tun" ]; then
      #udp
      if [ "$enable_udp_proxy" -eq 1 ]; then
         modprobe xt_TPROXY >/dev/null 2>&1
         ip rule add fwmark "$PROXY_FWMARK" table "$PROXY_ROUTE_TABLE"
         ip route add local 0.0.0.0/0 dev lo table "$PROXY_ROUTE_TABLE"
         iptables -t mangle -N openclash
         iptables -t mangle -F openclash
         iptables -t mangle -A openclash -m set --match-set localnetwork dst -j RETURN
         iptables -t mangle -A openclash -m set --match-set wan_ac_black_ips dst -j RETURN >/dev/null 2>&1
         iptables -t mangle -A openclash -m set --match-set lan_ac_black_macs src -j RETURN >/dev/null 2>&1
         iptables -t mangle -A openclash -m set --match-set lan_ac_black_ips src -j RETURN >/dev/null 2>&1
         iptables -t mangle -A openclash -m set ! --match-set lan_ac_white_ips src -j RETURN >/dev/null 2>&1
         iptables -t mangle -A openclash -m set ! --match-set lan_ac_white_macs src -j RETURN >/dev/null 2>&1
         if [ "$en_mode" = "redir-host" ]; then
            iptables -t mangle -A openclash -m set --match-set china_ip_route dst -j RETURN >/dev/null 2>&1
         fi
         iptables -t mangle -A openclash -p udp --dport 53 -j RETURN >/dev/null 2>&1
         iptables -t mangle -A openclash -p udp -j TPROXY --on-port "$proxy_port" --on-ip 0.0.0.0 --tproxy-mark "$PROXY_FWMARK"
         iptables -t mangle -A PREROUTING -p udp -j openclash
      fi
   fi

   #if [ "$en_mode" = "fake-ip" ]; then
      iptables -t nat -N openclash_output
      iptables -t nat -F openclash_output
      iptables -t nat -A openclash_output -m set --match-set localnetwork dst -j RETURN
      #iptables -t nat -A openclash_output -p tcp -d 198.18.0.0/16 -j REDIRECT --to-ports "$proxy_port"
      iptables -t nat -A openclash_output -m owner ! --uid-owner 65534 -p tcp -m multiport --dport 80,443 -j REDIRECT --to-ports "$proxy_port"
      if [ "$en_mode" = "fake-ip" ]; then
         iptables -t nat -A openclash_output -m owner ! --uid-owner 65534 -p tcp -d 198.18.0.0/16 -j REDIRECT --to-ports "$proxy_port"
      fi
      iptables -t nat -I OUTPUT -j openclash_output
   #fi

   #if [ "$ipv6_enable" -eq 1 ]; then
   #   #tcp
   #   ip6tables -t nat -N openclash
   #   if [ -n "$lan_ip6" ]; then
   #      for lan_ip6s in $lan_ip6; do
   #         ip6tables -t nat -A openclash -d "$lan_ip6s" -j RETURN 2>/dev/null
   #      done
   #   fi
   #   ip6tables -t nat -A openclash -p tcp -j REDIRECT --to-ports "$proxy_port"
   #   ip6tables -t nat -A PREROUTING -p tcp -j openclash

      #udp
      #if [ "$enable_udp_proxy" -eq 1 ]; then
      #   ip6tables -t mangle -N openclash
      #   if [ -n "$lan_ip6" ]; then
      #      for lan_ip6s in $lan_ip6; do
      #         if [ "$enable_udp_proxy" -eq 1 ]; then
      #            ip6tables -t mangle -A openclash -d "$lan_ip6s" -j RETURN 2>/dev/null
      #         fi
      #      done
      #   fi
      #   ip6tables -t mangle -A openclash -p udp -j TPROXY --on-port "$proxy_port" --tproxy-mark "$PROXY_FWMARK"
      #   ip6tables -t mangle -A PREROUTING -p udp -j openclash
      #fi
   #fi 2>/dev/null
fi
if [ -n "$en_mode_tun" ]; then
   #TUN模式
   #启动TUN
   if [ "$en_mode_tun" -eq 2 ]; then
      ip tuntap add user root mode tun clash0
      ip link set clash0 up
      ip route replace default dev clash0 table "$PROXY_ROUTE_TABLE"
   elif [ "$en_mode_tun" -eq 1 ] || [ "$en_mode_tun" -eq 3 ]; then
      TUN_WAIT=0
      while ( [ -n "$(pidof clash)" ] && [ -z "$(ip route list |grep utun)" ] && [ "$TUN_WAIT" -le 3 ] )
      do
         TUN_WAIT=$(expr "$TUN_WAIT" + 1)
         sleep 2
      done
      ip route replace default dev utun table "$PROXY_ROUTE_TABLE"
   fi
   ip rule add fwmark "$PROXY_FWMARK" table "$PROXY_ROUTE_TABLE"
   
   #设置防火墙
   if [ "$en_mode" = "fake-ip" ]; then
      iptables -t mangle -N openclash_output
      iptables -t mangle -F openclash_output
      iptables -t mangle -A openclash_output -m set --match-set localnetwork dst -j RETURN
      if [ "$en_mode_tun" -ne 3 ]; then
         iptables -t mangle -A openclash_output -m owner ! --uid-owner 65534 -p tcp -m multiport --dport 80,443 -j MARK --set-mark "$PROXY_FWMARK"
         iptables -t mangle -A openclash_output -m owner ! --uid-owner 65534 -d 198.18.0.0/16 -j MARK --set-mark "$PROXY_FWMARK"
      else
         iptables -t mangle -A openclash_output -m owner ! --uid-owner 65534 -p udp -d 198.18.0.0/16 -j MARK --set-mark "$PROXY_FWMARK"
      fi  
      iptables -t mangle -I OUTPUT -j openclash_output
   elif [ "$en_mode" = "redir-host" ] && [ "$en_mode_tun" -ne 3 ]; then
      iptables -t mangle -N openclash_output
      iptables -t mangle -F openclash_output
      iptables -t mangle -A openclash_output -m set --match-set localnetwork dst -j RETURN
      iptables -t mangle -A openclash_output -m owner ! --uid-owner 65534 -p tcp -m multiport --dport 80,443 -j MARK --set-mark "$PROXY_FWMARK"
      iptables -t mangle -I OUTPUT -j openclash_output
   fi
   
   iptables -t mangle -N openclash
   iptables -t mangle -F openclash
   iptables -t mangle -N openclash_dns_hijack
   iptables -t mangle -F openclash_dns_hijack
   #其他流量
   iptables -t mangle -A openclash -m set --match-set localnetwork dst -j RETURN >/dev/null 2>&1
   iptables -t mangle -A openclash -m set --match-set wan_ac_black_ips dst -j RETURN >/dev/null 2>&1
   iptables -t mangle -A openclash -m set --match-set lan_ac_black_ips src -j RETURN >/dev/null 2>&1
   iptables -t mangle -A openclash -m set --match-set lan_ac_black_macs src -j RETURN >/dev/null 2>&1
   iptables -t mangle -A openclash -m set ! --match-set lan_ac_white_ips src -j RETURN >/dev/null 2>&1
   iptables -t mangle -A openclash -m set ! --match-set lan_ac_white_macs src -j RETURN >/dev/null 2>&1
   if [ "$en_mode" = "redir-host" ]; then
      iptables -t mangle -A openclash -m set --match-set china_ip_route dst -j RETURN >/dev/null 2>&1
   fi
   iptables -t mangle -A openclash -j MARK --set-mark "$PROXY_FWMARK"
   
   if [ "$en_mode_tun" -ne 3 ]; then
      iptables -t mangle -I PREROUTING -j openclash
      iptables -t nat -I PREROUTING -p tcp --dport 53 -j ACCEPT
   else
      iptables -t mangle -I PREROUTING -p tcp --dport 53 -j openclash_dns_hijack
      iptables -t mangle -A openclash_dns_hijack -d 8.8.8.8 -j MARK --set-mark "$PROXY_FWMARK"
      iptables -t mangle -A openclash_dns_hijack -d 8.8.4.4 -j MARK --set-mark "$PROXY_FWMARK"
      iptables -t mangle -I PREROUTING -p udp -j openclash
      iptables -t nat -I PREROUTING -p tcp -d 8.8.8.8 -j ACCEPT
      iptables -t nat -I PREROUTING -p tcp -d 8.8.4.4 -j ACCEPT
   fi
   
   #ipv6
   #    if [ "$ipv6_enable" -eq 1 ]; then
   #        ip6tables -t mangle -I PREROUTING -j MARK --set-mark "$PROXY_FWMARK"
   #    fi
fi

#端口转发
config_load "firewall"
config_foreach firewall_redirect_exclude "redirect"
config_foreach firewall_rule_exclude "rule"
}

revert_firewall()
{
   rm -rf /var/etc/openclash.include 2>/dev/null

   #ipv4

   ip rule del fwmark "$PROXY_FWMARK" table "$PROXY_ROUTE_TABLE" >/dev/null 2>&1
   ip route del local 0.0.0.0/0 dev lo table "$PROXY_ROUTE_TABLE" >/dev/null 2>&1

   iptables -t nat -D PREROUTING -p tcp --dport 53 -j ACCEPT >/dev/null 2>&1

   out_lines=$(iptables -nvL OUTPUT -t nat |sed 1,2d |sed -n '/openclash/=' 2>/dev/null |sort -rn)
   for out_line in $out_lines; do
      iptables -t nat -D OUTPUT "$out_line" >/dev/null 2>&1
   done >/dev/null 2>&1
   iptables -t nat -D OUTPUT -j openclash_output >/dev/null 2>&1
   
   out_lines=$(iptables -nvL OUTPUT -t mangle |sed 1,2d |sed -n '/openclash/=' 2>/dev/null |sort -rn)
   for out_line in $out_lines; do
      iptables -t mangle -D OUTPUT "$out_line" >/dev/null 2>&1
   done >/dev/null 2>&1
   iptables -t mangle -D OUTPUT -j openclash_output >/dev/null 2>&1

   pre_lines=$(iptables -nvL PREROUTING -t nat |sed 1,2d |sed -n '/8\.8\./=' 2>/dev/null |sort -rn)
   for pre_line in $pre_lines; do
      iptables -t nat -D PREROUTING "$pre_line" >/dev/null 2>&1
   done >/dev/null 2>&1

   pre_lines=$(iptables -nvL PREROUTING -t mangle |sed 1,2d |sed -n '/openclash/=' 2>/dev/null |sort -rn)
   for pre_line in $pre_lines; do
      iptables -t mangle -D PREROUTING "$pre_line" >/dev/null 2>&1
   done >/dev/null 2>&1

   pre_lines=$(iptables -nvL PREROUTING -t nat |sed 1,2d |sed -n '/openclash/=' 2>/dev/null |sort -rn)
   for pre_line in $pre_lines; do
      iptables -t nat -D PREROUTING "$pre_line" >/dev/null 2>&1
   done >/dev/null 2>&1
   iptables -t nat -D PREROUTING -p tcp -j openclash >/dev/null 2>&1

   #ipv6
   #ip6tables -t mangle -F openclash >/dev/null 2>&1
   #ip6tables -t mangle -D PREROUTING -p udp -j openclash >/dev/null 2>&1
   #ip6tables -t mangle -X openclash >/dev/null 2>&1

   iptables -t nat -F openclash >/dev/null 2>&1
   iptables -t nat -X openclash >/dev/null 2>&1
   
   iptables -t nat -F openclash_output >/dev/null 2>&1
   iptables -t nat -X openclash_output >/dev/null 2>&1

   ip6tables -t nat -F openclash >/dev/null 2>&1
   ip6tables -t nat -D PREROUTING -p tcp -j openclash >/dev/null 2>&1
   ip6tables -t nat -X openclash >/dev/null 2>&1

   #TUN
   ip route del default dev clash0 table "$PROXY_ROUTE_TABLE" >/dev/null 2>&1
   ip route del default dev utun table "$PROXY_ROUTE_TABLE" >/dev/null 2>&1
   ip rule del fwmark "$PROXY_FWMARK" table "$PROXY_ROUTE_TABLE" >/dev/null 2>&1
   ip link set dev clash0 down >/dev/null 2>&1
   ip tuntap del clash0 mode tun >/dev/null 2>&1

   iptables -t mangle -D OUTPUT -j openclash_output >/dev/null 2>&1
   iptables -t mangle -D PREROUTING -j openclash >/dev/null 2>&1
   iptables -t mangle -D PREROUTING -p udp -j openclash >/dev/null 2>&1
   iptables -t mangle -D PREROUTING -p tcp --dport 53 -j openclash_dns_hijack >/dev/null 2>&1
   iptables -t mangle -F openclash >/dev/null 2>&1
   iptables -t mangle -X openclash >/dev/null 2>&1
   iptables -t mangle -F openclash_dns_hijack >/dev/null 2>&1
   iptables -t mangle -X openclash_dns_hijack >/dev/null 2>&1
   iptables -t mangle -F openclash_output >/dev/null 2>&1
   iptables -t mangle -X openclash_output >/dev/null 2>&1

   #ip6tables -t mangle -D PREROUTING -j MARK --set-mark "$PROXY_FWMARK" >/dev/null 2>&1

   ipset destroy localnetwork >/dev/null 2>&1
   ipset destroy china_ip_route >/dev/null 2>&1
   ipset destroy lan_ac_white_ips >/dev/null 2>&1
   ipset destroy lan_ac_black_ips >/dev/null 2>&1
   ipset destroy lan_ac_white_macs >/dev/null 2>&1
   ipset destroy lan_ac_black_macs >/dev/null 2>&1
   ipset destroy wan_ac_black_ips >/dev/null 2>&1
}

get_config()
{
   rule_source=$(uci get openclash.config.rule_source 2>/dev/null)
   enable_custom_dns=$(uci get openclash.config.enable_custom_dns 2>/dev/null)
   enable_custom_clash_rules=$(uci get openclash.config.enable_custom_clash_rules 2>/dev/null) 
   da_password=$(uci get openclash.config.dashboard_password 2>/dev/null)
   cn_port=$(uci get openclash.config.cn_port 2>/dev/null)
   proxy_port=$(uci get openclash.config.proxy_port 2>/dev/null)
   proxy_mode=$(uci get openclash.config.proxy_mode 2>/dev/null)
   ipv6_enable=$(uci get openclash.config.ipv6_enable 2>/dev/null)
   http_port=$(uci get openclash.config.http_port 2>/dev/null)
   socks_port=$(uci get openclash.config.socks_port 2>/dev/null)
   enable_redirect_dns=$(uci get openclash.config.enable_redirect_dns 2>/dev/null)
   lan_ip=$(uci get network.lan.ipaddr 2>/dev/null |awk -F '/' '{print $1}' 2>/dev/null)
   wan_ip4=$(ifconfig | grep 'inet addr' | awk '{print $2}' | cut -d: -f2 2>/dev/null)
   lan_ip6=$(ifconfig | grep 'inet6 addr' | awk '{print $3}' 2>/dev/null)
   disable_masq_cache=$(uci get openclash.config.disable_masq_cache 2>/dev/null)
   log_level=$(uci get openclash.config.log_level 2>/dev/null)
   intranet_allowed=$(uci get openclash.config.intranet_allowed 2>/dev/null)
   enable_udp_proxy=$(uci get openclash.config.enable_udp_proxy 2>/dev/null)
   operation_mode=$(uci get openclash.config.operation_mode 2>/dev/null)
   lan_ac_mode=$(uci get openclash.config.lan_ac_mode 2>/dev/null)
   enable_rule_proxy=$(uci get openclash.config.enable_rule_proxy 2>/dev/null)
   stack_type=$(uci get openclash.config.stack_type 2>/dev/null)
   china_ip_route=$(uci get openclash.config.china_ip_route 2>/dev/null)
   small_flash_memory=$(uci get openclash.config.small_flash_memory 2>/dev/null)
   uci set openclash.config.restricted_mode=0 && uci commit openclash
}

start()
{
   #禁止多个实例
   status=$(unify_ps_status "/etc/init.d/openclash")
   [ "$status" -gt "3" ] && echo "${LOGTIME} Warning: Multiple Start Scripts Running, Exit..." >> $LOG_FILE && exit 0
   
   enable=$(uci get openclash.config.enable 2>/dev/null)
   [ "$enable" != "1" ] && echo "${LOGTIME} Warning: OpenClash Now Disabled, Need Start From Luci Page, Exit..." >> $LOG_FILE && exit 0

   config_choose

   echo "OpenClash 开始启动..." >$START_LOG
   do_run_mode
   
   echo "第一步: 获取配置..." >$START_LOG
   get_config
   
   #检查文件是否存在
   do_run_file
   
   echo "第二步: 配置文件检查..." >$START_LOG
   yml_check "$en_mode" "$enable_custom_dns" "$CONFIG_FILE" "$BACKUP_FILE" "$START_BACKUP"

   echo "第三步: 修改配置文件..." >$START_LOG
   config_load "openclash"
   config_foreach yml_auth_get "authentication"
   yml_auth_custom "$CHANGE_FILE"
   yml_dns_custom "$enable_custom_dns" "$DNS_FILE" "$FALLBACK_FILTER_FILE"
   /usr/share/openclash/yml_change.sh >/dev/null 2>&1 "$LOGTIME" "$en_mode" "$enable_custom_dns" "$da_password" "$cn_port" "$proxy_port" "$CHANGE_FILE" "$ipv6_enable" "$http_port" "$socks_port" "$lan_ip" "$log_level" "$proxy_mode" "$intranet_allowed" "$en_mode_tun" "$stack_type" "$dns_port" "$core_type" &
   /usr/share/openclash/yml_rules_change.sh >/dev/null 2>&1 "$LOGTIME" "$rule_source" "$enable_custom_clash_rules" "$RULE_FILE" "$set_rule_file" "$en_mode" "$enable_rule_proxy" "$BACKUP_FILE" "$RULE_PROVIDER_FILE" &
   wait

   yml_provider_path "$PROXY_PROVIDER_FILE" "proxy_provider"
   yml_provider_path "$RULE_PROVIDER_FILE" "rule_provider"
   yml_custom_rule_provider
   yml_game_custom

   echo "第四步: 合并配置文件修改..." >$START_LOG
   yml_merge
   
   echo "第五步: 启动主程序..." >$START_LOG
   start_run_core
   
   echo "第六步: 检查内核启动状态..." >$START_LOG
   check_core_status

   #检测proxy_provider配置文件状态
   echo "第七步: 等待主程序下载外部文件..." >$START_LOG
   yml_provider_check "$PROXY_PROVIDER_FILE" "proxy_provider"
   yml_provider_check "$RULE_PROVIDER_FILE" "rule_provider"

   try_restore_start
   
   echo "第八步: 设置控制面板..." >$START_LOG
   ln -s /usr/share/openclash/yacd /www/luci-static/openclash 2>/dev/null
       
   echo "第九步: 设置防火墙规则..." >$START_LOG
   set_firewall

   echo "第十步: 重启 Dnsmasq 程序..." >$START_LOG
   change_dns "$enable_redirect_dns" "$disable_masq_cache"
   /etc/init.d/dnsmasq restart >/dev/null 2>&1
            
   echo "第十一步: 还原策略组节点状态..." >$START_LOG
   /usr/share/openclash/openclash_history_set.sh
   
   echo "第十二步: 添加计划任务,启动进程守护程序..." >$START_LOG
   add_cron
   if [ -z "$(uci get dhcp.lan.dhcpv6 2>/dev/null)" ] && [ "$(uci get openclash.config.restricted_mode 2>/dev/null)" != "1" ]; then
      echo "OpenClash 启动成功，请等待服务器上线！" >$START_LOG
      echo "${LOGTIME} OpenClash Start Successful" >> $LOG_FILE
      sleep 5
   elif [ -n "$(uci get dhcp.lan.dhcpv6 2>/dev/null)" ]; then
      echo "OpenClash 启动成功，检测到您启用了IPV6的DHCP服务，可能会造成连接异常！" >$START_LOG
      echo "${LOGTIME} Warning: OpenClash Start Successful, Please Note That Network May Abnormal With IPV6's DHCP Server" >> $LOG_FILE
      sleep 5
   fi
   if [ "$(uci get openclash.config.restricted_mode 2>/dev/null)" = "1" ]; then
      echo "OpenClash 使用原始配置文件启动成功，部分设置可能未生效！" >$START_LOG
      echo "${LOGTIME} Warning: OpenClash Start Successful With Raw Config File, Please Note That It's Restricted Mode Now" >> $LOG_FILE
      sleep 5
   fi
   echo "OpenClash Already Start"
   echo "" >$START_LOG
   rm -rf $START_BACKUP 2>/dev/null
   rm -rf /tmp/yaml_* 2>/dev/null
}

stop()
{
   
   enable=$(uci get openclash.config.enable 2>/dev/null)

   echo "OpenClash 开始关闭..." >$START_LOG
   echo "第一步: 备份当前节点状态..." >$START_LOG
   /usr/share/openclash/openclash_history_get.sh 2>/dev/null

   echo "第二步: 删除 OpenClash 防火墙规则..." >$START_LOG
   revert_firewall

   echo "第三步: 关闭 OpenClash 守护程序..." >$START_LOG
   watchdog_pids=$(unify_ps_pids "openclash_watchdog.sh")
   for watchdog_pid in $watchdog_pids; do
      kill -9 "$watchdog_pid" >/dev/null 2>&1
   done >/dev/null 2>&1

   echo "第四步: 关闭 Clash 主程序..." >$START_LOG
   if [ "$enable" != "1" ]; then
      kill_clash
   fi

   echo "第五步: 重启 Dnsmasq 程序..." >$START_LOG
   dns_port=$(uci get openclash.config.dns_port 2>/dev/null)
   redirect_dns=$(uci get openclash.config.redirect_dns 2>/dev/null)
   masq_cache=$(uci get openclash.config.masq_cache 2>/dev/null)
   revert_dns "$redirect_dns" "$masq_cache" "$dns_port" "$enable"
   /etc/init.d/dnsmasq restart >/dev/null 2>&1

   echo "第六步：删除 OpenClash 残留文件..." >$START_LOG
   if [ "$enable" != "1" ]; then
      rm -rf $LOG_FILE 2>/dev/null
      rm -rf /tmp/openclash_debug.log 2>/dev/null
      rm -rf /www/luci-static/openclash 2>/dev/null
      rm -rf /tmp/openclash_last_version 2>/dev/null
      rm -rf /tmp/clash_last_version 2>/dev/null
      rm -rf /tmp/Proxy_Group 2>/dev/null
      rm -rf /tmp/rules_name 2>/dev/null
      rm -rf /tmp/rule_providers_name 2>/dev/null
      echo "OpenClash 关闭成功！" >$START_LOG
      sleep 5
   fi
   
   rm -rf /tmp/yaml_* 2>/dev/null
   rm -rf $START_LOG 2>/dev/null
   del_cron
   echo "OpenClash Already Stop"
}


restart()
{
   stop
   start
}

reload()
{
   if pidof clash >/dev/null; then
      revert_firewall 2>/dev/null
      do_run_mode 2>/dev/null
      get_config 2>/dev/null
      set_firewall 2>/dev/null
      echo "${LOGTIME} Reload OpenClash Firewall Rules" >> $LOG_FILE
   fi
}
